// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test} from "forge-std/Test.sol";
import {console} from "forge-std/console.sol";

import {UniswapV3Oracle} from "src/oracles/uniswap/UniswapV3Oracle.sol";
import {IUniswapV3Oracle} from "src/oracles/uniswap/interfaces/IUniswapV3Oracle.sol";

import {MockUniswapV3Pool} from "../utils/mocks/MockUniswapV3Pool.sol";
import {BasicContractsFixture} from "../fixtures/BasicContractsFixture.t.sol";

/**
 * @title UniswapV3Oracle Vulnerability Proof of Concept
 * @notice Demonstrates the critical vulnerability where peek() always returns success=true
 *         regardless of pool data quality, leading to false confidence in price feeds
 */
contract UniswapV3Oracle_Vulnerability_PoC is Test, BasicContractsFixture {
    // Real mainnet pools for testing
    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // Using USDT as jUSD
    address internal constant USDC_MAINNET =
        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address internal constant USDC_POOL =
        0x3416cF6C708Da44DB2624D63ea0AAef7113527C6; // USDT/USDC pool
    address internal constant WETH_POOL =
        0x11b815efB8f581194ae79006d24E0d814B7697F6; // USDT/WETH pool

    UniswapV3Oracle internal vulnerableOracle;
    MockUniswapV3Pool internal mockPool;

    function setUp() public {
        // Fork mainnet to use real pool data
        vm.createSelectFork(vm.envString("MAINNET_RPC_URL"), 21_722_108);

        // Initialize the BasicContractsFixture
        init();

        // Deploy mock pool for manipulation testing
        mockPool = new MockUniswapV3Pool();

        // Setup initial pools array with real pool
        address[] memory initialPools = new address[](1);
        initialPools[0] = USDC_POOL;

        // Deploy vulnerable oracle using USDT as jUSD and USDC from fixture
        vulnerableOracle = new UniswapV3Oracle({
            _initialOwner: OWNER,
            _jUSD: USDT,
            _quoteToken: address(usdc), // Use USDC from BasicContractsFixture
            _quoteTokenOracle: address(usdcOracle), // Use oracle from BasicContractsFixture
            _uniswapV3Pools: initialPools
        });

        // Update the manager to use our vulnerable oracle instead of the default jUsdOracle
        vm.startPrank(OWNER);
        manager.requestNewJUsdOracle(address(vulnerableOracle));
        skip(manager.timelockAmount() + 1);
        manager.acceptNewJUsdOracle();
        vm.stopPrank();
    }

    function test_vulnerability_staleHistoricalData() public {
        // The oracle queries data with offsets: 3600s, 1800s, 0s
        // But doesn't validate if this historical data is relevant

        // In a real attack, an attacker would:
        // 1. Monitor for periods where historical prices differ significantly from current
        // 2. Force oracle to rely on historical data during low activity
        // 3. Exploit the price difference

        (bool success, uint256 rate) = vulnerableOracle.peek("");

        console.log("Oracle returns historical data as current:");
        console.log("Success:", success);
        console.log("Rate:", rate);

        // VULNERABILITY: No validation that historical data represents current market
        assertTrue(
            success,
            "Oracle accepts historical data without current market validation"
        );
    }

        
}
